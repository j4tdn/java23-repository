1. Các hướng xây dựng, phát triển, giải quyết một bài toán trong lập trình

+ FOP(Functional Oriented Programming): Lập trình hướng chức năng(hàm)
  --> Khi code 1 bài toán, xem bài toán đó như 1 chức năng rồi chia nhỏ chức năng đó thành
  	  các chức năng nhỏ hơn để giải quyết
  --> 1 bài toán là 1 hàm lớn -> chưa/gọi các hàm nhỏ hơn
  
Hạn chế: Vì các hàm gọi lẫn nhau, nếu 1 hàm xảy ra lỗi sẽ kéo theo cả hệ thống lỗi
		 Dữ liệu dùng chung, không có phân quyền dữ liệu.

+ OOP(Object Oriented Programming): Lập trình hướng đối tượng(chứa một hoạc nhiều thông tin
  									bên trong)
  --> System = ập hợp các Object
  --> Object = attribute(s) + method(s)
  			 = data structure + function

VD: Bài toán quản lý cửa hàng thời trang
Bài toán sẽ có những đối tượng như: 
  - Mặt Hàng, 
  	--> Lưu trữ: mã mặt hàng, tên mặt hàng, giá bán, giá mua, số lượng, kích cỡ
  	--> Chức năng: liệt kê các mặt hàng, tìm kiếm, chọn để bán...
  - Đơn hàng:
  	--> Lưu trữ: mã đớn hàng, danh sách mặt hàng, số lượng, tổng tiền, tên khách hàng,...
  	--> Chức năng: tạo đơn hàng, xuất hóa đơn, thanh toán offline/oneline ...
  
+ AOP(Aspect Oriented Programming): Lập trình hướng khía cạnh
  --> Xây dựng, phát triển trong các thư việ, framework
  --> Khi gọi/thực thi 1 chức năng thì chức năng đó sẽ được thực thi tự động kèm với 1/n chức
  	  năng(khía cạnh) khác theo cấu hình.
  	  
VD: Ngôn ngữ JDBC/JPA-Hibernate: Database Connection
	+Chức năng chuyển/nhận tiền qua các app ngân hàng, làm 2 việc
	- Đăng nhập
	- Người chuyển: Trừ số tiền từ tài khoản --> hamA()
	- Người nhận:	Nhận được số tiền		 --> hamB()
	--> Vấn đề: lỗi mạng, ứng dụng bị lỗi -> số tiền từ người chuyển bị trừ nhưng người nhận
		chưa nhận được
	--> commit, rollback
		
	hamChuyentien() {
		hamA();
		hamB();
	}
	
	--> CronJob(QuartJob): Cấu hình 1 chức năng sẽ được thực thi ở thời điểm nào đó
	
	--> Cấu hình sao đó để khi gọi hamChuyenTien(), 
		-> Nếu có lỗi xảy ra thì gọi lệnh hàm rollback để trả về dữ liệu ban đầu.
		-> Nếu thực thi ok -> commit lưu dữ liệu
	
=========================== OOP trong Java ==============================================
+ Object: là khái niệm để mô tả các thực thể trong thế giới thực, thông tin rõ ràng, cụ thể
		  phân biệt được với các thực thể khác --> đối tượng
		  VD: 2 chiếc xe hơi sẽ khác nhàu về màu sắc, hãng xe, số chỗ ngồi...
		  
+ Class : là khái niệm trừu tượng dùng để chỉ taaoj hợp các đối tượng có chung thuộc tính,
		  phương thức.
		  VD: 2 chiếc xe hơi sẽ khác nhàu về màu sắc, hãng xe, số chỗ ngồi
		  	  -> mỗi đối tượng xe có thể có màu sắc, hãng xe, số chỗ ngồi khác nhau nhưng đều
		  	  có thông tin: máu sắc, hãng xe, số chỗ ngồi
		  class Car: color, model, noSeats
--> Khái niệm class, object chỉ mang tính chất tương đối
	1 class cũng có thể là 1 object hay ngược lại trong các trường hợp khác nhau
	
VD: XeHoi: XeXanh, XeVang, XeDo
	PhuongTien: XeHoi, XeDap, XeMay
	
---> CODE: Class: attributes + methods
		   --> gọi hàm khởi tạo từ class
		   	   --> tạo ra Object
		   	   

Class
---------------------------------------
+ Attribute
 	--> Thông thường sẽ khai báo private
 	--> Lý do: nếu để public thì sẽ được truy cập từ bất cứ class nào
  			 rơi vào hạn chế của FOP, không phân quyền dữ liệu quản lý cho từng đối tượng.
 	--> Vấn đề: Tạo 1 class ra, dùng nó ở nhiều nơi cho bàn toán
  			  private -> k truy cập được
  			  getter -> truy cập lấy giá trị của thuộc tính
  			  setter -> truy cập gán, cập nhật giá trị của thuộc tính mà không làm mất đi
  			  cấu trúc dữ liệu của class.

  			  VD:
  			  class A {
  			  	public List<Item> items = new ArrayList<>();	// dynamic array
  			  	private List<Item> items = new ArrayList<>();
  			  	
  			  	public List<Item> get Item(){
  			  		return items;
  			  	}
  			  	
  			  	public void add(Item item) {
  			  		items.add(item)
  			  	}
  			  }
			  Nếu để public:		  
  			  --> A a1 = new A();
  			  --> a1.items = Arrays.asList(...); --> items -> fixed-length array
  			  Private:
  			  --> a1.add(...);
  			  
+ constructor: hàm khởi tạo
	--> khởi tạo đối tượng cho class, thông qua từ khóa new
	--> tạo ra 1 ô nhớ tại vùng nhớ heap
	
+ getter/setter
	--> lấy/cập nhật giá trị cho thuộc tính của đối tượng
	--> đối tượng đó phải tồn tại, có giá trị ở HEAP rồi
+ toString()
	--> được gọi tự động khi in ra biến của class
	
------------------------------------------------------------------------------------------
Từ khóa Static
--> static class
	// Non-static: thuộc phạm vi của đối tượng
	// Static	 : thuộc phạm vi class, dùng chung cho tất cả các đối tượng của class

--> static attribute
	// non-static: nếu hàm phụ thuộc vào đối tượng đang gọi
				 : với mỗi đối tượng khác nhau, khi gọi hàm kết quả có thể khác nhau
	
	// static	 : nếu hàm không phụ thuộc vào đối tượng đang gọi
				 : dùng bất kỳ đối tượng nào gọi cũng không ảnh hưởng đến kết quả của hàm

--> thứ tự khởi tạo trước sau của static/non-static attribute, method
	lúc runtime khi một class khởi tạo trước -> tạo ra đối tượng từ class
	--> static method/attribute sẽ được khởi tạo trước
	--> non-static method/attribute sẽ được khởi tạo khi tạo ra đối tượng
	
--> static method










  			  
  			  