1. Các hướng xây dựng, phát triển, giải quyết 1 bài toán trong lập trình

+ FOP (Functional Oriented Programming): Lập trình hướng chức năng, hàm
--> Khi code 1 bài toán, xem bài toán như là 1 chức năng
	--> Chia nhỏ chức năng đó thành các chức năng nhỏ hơn để giải quyết
--> 1 bài toán là 1 hàm lớn --> chứa/gọi các hàm nhỏ hơn

Hạn chế: Vì các hàm gọi lẫn nhau, nếu 1 hàm xảy ra lỗi kéo theo cả hệ thống
		--> Dữ diệu dùng chung, không có phân quyền dữ liệu

+ OOP (Object Oriented Programming): Lập trình hứng đối tượng 
		--> Chứa 1 hoặc nhiều thông tin bên trong
--> System = Tập hợp các Object
--> Object = attribute(s) + method(s) = data structure + function

Ex: Bài toán quản lí cửa hàng thời trang
+ Bài toán sẽ có những đối tượng: 
 - Mặt Hàng
 	--> Lưu trữ: mã mặt hàng, tên mặt hàng, giá bán, giá mua, số lượng, kích cỡ
 	--> Chức năng: liệt kê các mặt hàng, tìm kiếm, chọn để bán,...
 - Đơn Hàng
 	--> Lưu trữ: mã đơn hàng, danh sách các mặt hàng, số lượng, tổng tiền, khách hàng nào,...
 	--> Chức năng: Tạo đơn hàng, xuất hóa đơn, thanh toán offline/online....
 	
+ AOP (Aspect Object Progamming): Lập trình hướng khía cạnh
--> Xây dựng, phát triển trong các thư viện, framework
--> Khi gọi/thực thi 1 chức năng, chức năng đó sẽ được thực thi tự động kèm với 
1/n chức năng khác theo cấu hình

Ex: Ngôn ngữ JDBC/JPA-Hibernate: Database Connection
+ Chức năng chuyển/nhận tiền qua các app ngân hàng

--> Đăng nhập
 --> Làm 2 việc
 	- Người chuyển: Trừ số tiền từ tài khoản --> hamA()
 	- Người nhận: Nhận được số tiền 		 --> hamB()
 --> Vấn đề: Lỗi mạng, ứng dụng bị lỗi: số tiền từ người chuyển đã bị trừ, người nhận lại
 chưa nhận được tiền
 
 --> commit, rollback
 
 @Transactional
 hamchuyentien() {
 	hamA();
 	hamB();
 }
 
 --> Cấu hình sao đó để khi gọi hàm hamchuyentien()
 --> nếu có lỗi xảy ra thì gọi lệnh hàm rollback đến trả về lại dữ liệu ban đầu
 --> nếu thực thi ok --> commit lưu dữ liệu 
 
 
 (+) CronJob(QuartJob): Cấu hình 1 chức năng sẽ được thực thi ở thời diểm nào đó
 
 
 
 
 ================= OOP trong Java ======================
 + Object: là khái niệm dùng để mô tả các thực thể trong thế giới thực
 --> Thông tin rõ ràng, cụ thể, phân biệt được với các thực thể khác
 --> ĐỐI TƯỢNG
 Ex: 2 chiếc xe hơi khác màu sắc, hãng xe, số chỗ ngồi
 
 + Class: là 1 khái niệm trừu tượng dùng để chỉ 1 tập hợp các đối tượng có chung thuộc tính
 và phương thức
 Ex: 2 chiếc xe hơi khác màu sắc, hãng xe, số chỗ ngồi
 	--> mỗi đối tượng xe có thể có màu sắc, hãng xe, số chỗ ngồi giống hoặc khác nhau
 	--> nhưng đều có thông tin: Màu sắc, hãng xe, số chỗ ngồi
 		--> class Car: color, model, noSeats
 --> khái niệm class, object chỉ mang tính chất tương đối
 	1 class cũng có thể là 1 object hay ngược lại trong các trường hợp khác nhau
 
 Ex: Xehoi: XeXanh, XeVang, XeXanh
 	 PhuongTien: XeHoi, XeDap, XeMay
 	 
 	 
 --> CODE: Class: attributes + methods
 		--> gọi hàm khởi tạo từ class
 		--> tạo ra Object
 		
=============================================================
Class
-------------
+ Attribute
--> Thông thường sẽ khai báo private
--> Lý do: nếu để public thì sẽ được truy cập từ bất cứ nơi nào
          rơi vào hạn chế của FOP, không phân quyền dữ liệu quản lý cho từng đối tượng
    Vấn đề:
 --> Tạo 1 class ra, dùng nó ở nhiều nơi cho bài toán
 	private --> không truy cập được
 	getter --> truy cập lấy giá trị của thuộc tính
 	setter --> truy cập gán, cập nhật lại giá trị của thuộc tính mà không làm mất đi cấu trúc dữ 
 				liệu của class
 	class A {
 		private List<Item> items = new ArrayList<>(); // dynamic array
 		private List<Item> items = new ArrayList<>();
 		
 		public List<Item> getItems() {
 			return items;
 		}
 		
 		public void add(Item item) {
 			item.add(item);
 		}
 	}
 	
+ Constructor: hàm khởi tạo
	--> khởi tạo đối tượng cho class, thông qua từ khóa 'new'
	--> tạo ra 1 ô nhớ tại vùng nhớ HEAP	
	
+ getter/setter
	--> lấy/cập nhật giá trị cho thuộc tính của đối tượng
	--> yêu cầu đối tượng đó phải tồn tại, có giá trị ở HEAP rồi
	
+ toString
	--> được gọi tự động khi in ra biến của class
	
------------------------
Từ khóa static
--> static attribute
	// non-static: thuộc phạm vi đối tượng
	// static:	   thuộc phạm vi class, dùng chung cho tất cả đối tượng của class

--> static method
	// non-static: nếu hàm phụ thuộc vào đối tượng đang gọi
	//           : với mỗi đối tượng khác nhau, khi gọi hàm kết quả có thể khác nhau
	
	// static    : nếu hàm không phụ thuộc vào đối tượng đang gọi
	             : dùng bất kỳ đối tượng nào gọi cũng không ảnh hưởng đến kết quả của hàm
	             
--> Thứ tự khởi tạo trước sau của static/non attribute, method
	Lúc runtime, các class khởi tạo trước -> tạo ra đối tượng từ class
	--> static method/attribut sẽ được khởi tạo trước
		--> non-static method/attribute sẽ được khởi tạo khi có tạo ra đối tượng
	
	
--> static class
	
	
	
	
	
	
	
	
	
	
	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	 		